TCP — Transfer Control Protocol. Протокол управления передачей. Он служит для   обеспечения и установление надежного соединения между двумя устройствами
и надежную передачу данных. При этом протокол TCP контролирует оптимальный размер передаваемого пакета данных, осуществляя новую посылку при сбое передачи.

IP — Internet Protocol. Интернет протокол или адресный протокол — основа всей архитектуры передачи данных. 
Протокол IP  служит для доставки сетевого пакета данных по нужному адресу. 
При этом информация разбивается на пакеты, которые независимо передвигаются по сети до нужного адресата.

В рамках протокола UDP данные передаются между узлами с помощью специальных пакетов данных, не требующих проверки.
При этом гарантии их получения не требуется. Данная технология не предусматривает удаление дубликатов пакетов, мониторинг и контроль их текущего расположения.

Socket создает конечную точку соединения и возвращает ее описатель.Первый параметр указывает, 
к какому семейству протоколов относится создаваемый сокет, а второй и третий параметры определяют конкретный протокол внутри данного семейства.
Второй параметр служит для задания вида интерфейса работы с сокетом – будет это потоковый сокет, сокет для работы с датаграммами или какой-либо иной. 
Третий параметр указывает протокол для заданного типа интерфейса. В стеке протоколов TCP/IP существует только один протокол для потоковых сокетов – 
TCP и только один протокол для датаграммных сокетов – UDP, поэтому для транспортных протоколов TCP/IP третий параметр игнорируется.

Когда сокет создан, необходимо настроить его адрес. Для этого используется системный вызов bind() .
Первый параметр вызова должен содержать дескриптор сокета, для которого производится настройка адреса. Второй и третий параметры задают этот адрес.

Во втором параметре должен быть указатель на структуру struct sockaddr, содержащую удаленную и локальные части полного адреса.

int bind(int sockd, 
         struct sockaddr *my_addr, 
         int addrlen);

Системный вызов bind служит для привязки созданного сокета к определенному полному адресу вычислительной сети.

Параметр sockd является дескриптором созданного ранее коммуникационного узла, т. е. значением, которое вернул системный вызов socket() .

Параметр my_addr представляет собой адрес структуры, содержащей информацию о том, куда именно мы хотим привязать наш сокет – то,
 что принято называть адресом сокета. Он имеет тип указателя на структуру-шаблон struct sockaddr, которая должна быть конкретизирована
  в зависимости от используемого семейства протоколов и заполнена перед вызовом.

Параметр addrlen должен содержать фактическую длину структуры, адрес которой передается в качестве второго параметра.
 Эта длина в разных семействах протоколов и даже в пределах одного семейства протоколов может быть различной.

int listen(int sockd, int backlog);

Системный вызов listen используется сервером, ориентированным на установление связи путем виртуального соединения,
 для перевода сокета в пассивный режим и установления глубины очереди для соединений.

Параметр sockd является дескриптором созданного ранее сокета, который должен быть переведен в пассивный режим, 
т. е. значением, которое вернул системный вызов socket() . Системный вызов listen требует предварительной настройки адреса сокета с помощью системного вызова bind() .

Параметр backlog определяет максимальный размер очередей для сокетов, находящихся в состояниях полностью и не полностью установленных соединений.

Системный вызов accept() позволяет серверу получить информацию о полностью установленных соединениях. 
Если очередь полностью установленных соединений не пуста, то он возвращает дескриптор для первого присоединенного сокета в этой очереди,
одновременно удаляя его из очереди. Если очередь пуста, то вызов ожидает появления полностью установленного соединения.
Системный вызов также позволяет серверу узнать полный адрес клиента, установившего соединение. 
У вызова есть три параметра: дескриптор слушающего сокета, через который ожидается установление соединения; 
указатель на структуру, в которую при необходимости будет занесен полный адрес сокета клиента, установившего соединение;
указатель на целую переменную, содержащую максимально допустимую длину этого адреса.


Вызов recv(), обычно, используется только на соединённом сокете. Системные вызовы recv(), recvfrom() и recvmsg() используются для получения сообщений из сокета.
Они могут использоваться для получения данных.

Функции recv и send
Эти две функции аналогичны стандартным функциям read и write, но для них требуется дополнительный аргумент.
#include <sys/socket.h>
ssize_t recv(int sockfd, void *buff, size_t nbytes, int flags);
ssize_t send(int sockfd, const void *buff, size_t nbytes, int flags);

Обе функции возвращают: количество прочитанных или записанных байтов в случае успешного выполнения, -1 в случае ошибки.

Системные вызовы send(), sendto() и sendmsg() используются для пересылки сообщений в другой сокет.
Вызов send() можно использовать, только если сокет находится в состоянии соединения (то есть известен получатель).
Вызов send() отличается от write(2) только наличием аргумента flags. Если значение flags равно нулю, то вызов send() эквивалентен write(2).

Когда сообщение не помещается в буфер отправки сокета, выполнение блокируется в send(), если сокет не находится в неблокирующем режиме.

Среди системных вызовов со стороны клиента появляется только один новый – connect() . 
Системный вызов connect() при работе с TCP-сокетами служит для установления логического соединения со стороны клиента. 
Вызов connect() скрывает внутри себя настройку сокета на выбранный системой порт и произвольный сетевой интерфейс (по сути дела, вызов bind() 
с нулевым номером порта и IP-адресом INADDR_ANY ). Вызов блокируется до тех пор, пока не будет установлено логическое соединение, 
или пока не пройдет определенный промежуток времени, который может регулироваться системным администратором.

Для установления соединения необходимо задать три параметра: дескриптор активного сокета, через который будет устанавливаться соединение,
полный адрес сокета сервера и его длину.